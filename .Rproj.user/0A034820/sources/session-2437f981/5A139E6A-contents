
Predict = function(res, Y, X, burnin, ich = 1) {
  require(caret)
  require(mvtnorm)
  # for (k in 1:K) {
  #   X[[k]] = cbind(X[[k]], Xc[[k]])
  #   Y[[k]] = c(Y[[k]], Yc[[k]])
  #   delta[[k]] = c(delta[[k]], deltac[[k]])
  # }
  nfold = 10
  GAMMAres = res$GAMMA_vec[[ich]][(burnin + 1):length(res$GAMMA_vec[[ich]])]
  Yaug = list()
  for(k in 1:K) {
    Yres = lapply(res$Y_vec[[ich]], function(x) x[[k]])
    Yres = Yres[(burnin + 1):length(res$Y_vec[[ich]])]
    Yaug[[k]] = Reduce("+", Yres) / length(Yres)
  }
  Ypred = lapply(1:K, function(k) rep(0, length(Yaug[[k]])))
  folds = lapply(Y, function(x) createFolds(x, k = nfold, list = FALSE, returnTrain = FALSE))

  for (k in 1:K) {
    for (m in 1:nfold) {
      Xtrain = X[[k]][folds[[k]] != m, ]
      Ytrain = Y[[k]][folds[[k]] != m]
      deltrain = delta[[k]][folds[[k]] != m]
      Xtest = X[[k]][folds[[k]] == m, ]
      Yhtest = Yaug[[k]][folds[[k]] == m]
      W = rep(0, length(GAMMAres))
      pred_list = list()
      for (i in 1:length(GAMMAres)) {
        gamma = which(GAMMAres[[i]][k, ] == 1)
        fit = glmnet(Xtrain[, gamma], as.matrix(data.frame(time = exp(Ytrain), status = deltrain)),
                     alpha = 1, family = "cox", intercept = FALSE)
        Bhat = as.numeric(coef(fit, s = fit$lambda[length(fit$lambda)]))
        if (length(gamma) == 1) {
          pred_list[[i]] = Xtest[, gamma] * Bhat
        } else {
          pred_list[[i]] = Xtest[, gamma] %*% Bhat
        }
        W[i] = dmvnorm(Yhtest, pred_list[[i]], sigma = diag(length(pred_list[[i]])))
      }
      pred_list = lapply(1:length(pred_list), function(i) pred_list[[i]])
      pred_list = Reduce("+", pred_list) / length(pred_list)
      Ypred[[k]][folds[[k]] == m] = pred_list
    }
  }
  return(Ypred)
}

